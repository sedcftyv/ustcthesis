% !TeX root = ../main.tex

\chapter{绪论}

\section{研究背景}
纹理(Texture)是三维渲染过程中使用的图像数据，该图像的各个像素称为纹素。如图\ref{fig:TextureMapping}所示，最简单的纹理是映射到三维表面的二维图像。
纹理不仅可以存储颜色，还可以存储高度、法线方向、材质属性（金属度、粗糙度）以及光照等信息。
如图\ref{fig:TextureMapping-sample}所示，A、B和C分别为漫反射纹理、法线纹理与高度纹理，漫反射纹理决定物体在标准光照条件下的外观、法线纹理为其增添阴影的视觉效果、高度纹理用于模拟表面凹凸的效果。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{figures/TextureMapping.png}
    \caption{纹理映射示例（三角形的相邻并不意味着相应纹理区域的相邻）\cite{paltashev2014texture}}
    \label{fig:TextureMapping}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{figures/TextureMapping-sample.png}
    \caption{不同类型的纹理（A-漫反射纹理，B-法线纹理，C-高度纹理）\cite{paltashev2014texture}}
    \label{fig:TextureMapping-sample}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{figures/Nanite.png}
    \caption{通过Nanite技术渲染的超高精度模型\cite{Nanite}}
    \label{fig:Nanite}
\end{figure}

随着图形技术的发展，计算机实时渲染的视觉质量已经接近视觉特效和电影制作的水平，这些质量改进是通过采用电影渲染中使用的方法来实现的，
例如基于物理的着色技术、光线追踪技术和用于精确全局照明的去噪技术，以及如图\ref{fig:Nanite}所示，类似 Nanite 的超高精度模型渲染技术。
这些高精度渲染技术依赖的高质量纹理占用了大量空间，例如《孤岛惊魂6》的游戏本体大小为91GB，而其高清纹理扩展包大小达到62GB，约为游戏本体大小的三分之二\cite{FarCry6}。
除了巨大的磁盘空间占用外，纹理在渲染过程中占用大量显存，这导致对显存大小以及带宽的较高要求。
因此各种纹理压缩技术被广泛采用，以减轻显存和带宽的压力。
在这种情况下，纹理存储在磁盘上并以某种压缩格式传输到 GPU 上。
解压缩仅发生在 GPU 上，这种方法节省了大量内存、显存以及带宽。
纹理压缩还可以降低功耗，因为内存与显存之间传输数据带来的功耗对于笔记本电脑、平板电脑和智能手机等移动设备尤为可观。

与传统图像不同，纹理需要在 GPU 端进行采样，这个过程具有高度随机性。渲染期间仅采样纹理的所需部分，并且事先不知道顺序。
此外，三维表面上三角形的相邻并不意味着相应纹理区域的相邻（见图\ref{fig:TextureMapping}）。
因此，渲染过程的整体性能高度依赖于纹理访问的效率。
由于缺乏对随机纹素访问的支持，标准压缩算法（RLE、LZW、Deflate） 和流行的压缩图像格式 （JPEG、PNG、TIFF）不适用于纹理，
这些算法如果不解压整个纹理就无法取得特定的纹素。
因此纹理压缩技术应运而生，通过高效的压缩算法减少显存占用和带宽消耗，同时尽可能保持视觉质量，从而提高渲染性能，成为计算机图形学中的关键技术之一。

随机访问决定了各种纹理压缩格式的主要特性。
大多数纹理压缩方案将整个图像划分为固定大小的块单独压缩，这类方案称为块压缩。
目前在不同平台上已经出现了多种不同的纹理块压缩格式：用于PC平台的DXT格式（包含BC1至BC7共7种格式），用于移动设备的ETC、PVRTC、以及ASTC格式。
这些格式在对应平台上支持GPU硬件解码与采样，因此具有较少的性能开销。
由于纹理的多样性，这些格式对每个纹理块都具有多种不同的编码配置，例如不同的分区压缩方案等。
这些编码配置增加了编码（压缩）过程的复杂性，但也使其对不同类型的纹理都具有较好的压缩效果。

最近已经出现了利用神经网络进行纹理压缩的工作，即神经压缩，例如NTC\cite{vaidyanathan2023random}和BCf\cite{weinreich2024real}。
神经压缩技术将纹理编码为神经特征，并通过多层全连接网络解码神经特征重建初始纹理。
这种技术可以同时压缩某种材质具有的一组纹理（漫反射纹理、法线纹理、金属度和粗糙度纹理），
相较于对纹理逐个进行压缩的传统纹理块压缩技术，相同质量下显著提升了纹理压缩率。
神经压缩技术中张量形式的神经特征可以使用传统纹理块压缩技术进一步压缩，例如BCf\cite{weinreich2024real}使用
BC6格式存储神经特征，相较于NTC\cite{vaidyanathan2023random}可以以更低显存占用存储神经特征。
随着硬件架构与制程的进步，目前越来越多的GPU设备除传统光栅化单元外，还集成了用于AI计算的张量计算单元，
这使得神经网络与图形渲染管线的结合更加高效，因此神经压缩技术可能成为未来的新一代纹理压缩技术。

\section{问题与挑战}

对于艺术家通过建模软件导出的物体材质纹理，例如颜色纹理、法线纹理、金属度纹理、粗糙度纹理和高度纹理等，目前的块压缩方法已经可以以较高质量进行压缩。
对于神经压缩技术中可学习的张量形式的神经特征，同样可以视作纹理并使用块压缩方法进行压缩，本文将这类纹理称为神经纹理。
由于现有纹理块压缩工具例如微软的DirectTex、英伟达的GPU纹理压缩工具NVTT、英特尔的ISPC纹理压缩器等都不支持
基于自动微分的可微计算，因此无法在神经纹理的优化过程中加入现有的块压缩编解码器，
只能在优化完成后对神经纹理进行块压缩，这种分阶段的方式显著地增加了神经压缩模型的整体误差。
与神经压缩模型类似，基于移动基分解的光照数据压缩技术\cite{silvennoinen2021moving}将光照数据压缩为
一系列的系数与基向量矩阵，HDR纹理的RGBM编码技术将RGB格式的HDR纹理编码为RGBA格式的LDR纹理，
这两种方法也可以与块压缩技术结合进行分阶段压缩，但由于无法将块压缩的编解码过程加入优化过程，
模型的整体误差也会显著增加。

为了降低神经纹理的块压缩对模型整体质量的影响，需要一个基于现有块压缩格式的可微编解码器，并结合到神经纹理的训练过程中。
目前已有相关工作对这个问题进行了研究，例如BCf\cite{weinreich2024real}提出了可微的BC6解码器，
在神经压缩模型中神经纹理的训练期间模拟 BC6 解压缩，训练完成后以BC6格式存储神经纹理，从而
实现以低显存占用存储高分辨率纹理。BCf\cite{weinreich2024real}的一个不足之处在于缺少可微编码器，导致
训练过程只能使用固定的编码配置，对于优化中不断发生改变的神经纹理，固定的编码配置可能无法达到最佳编码效果。

DXT格式包含BC6在内共有BC1至BC7 7种格式，
由于DXT格式具有一些共同特性，例如将纹素压缩为颜色端点与插值权重等，
因此设计一个DXT格式通用的可微块压缩模型是可行的。

本文提出了一种编解码架构的DXT 格式可微块压缩模型。基于 DXT 格式的定义，
设计可微的编码器、解码器，以及配置选择器，从而实现 DXT 格式编解码器的可微近似。

可微编解码器模型可以解决编码配置的选择问题，但具有两个挑战：

(1)编码过程的复杂性：DXT格式的解码过程基于线性插值，因此整体上是可微的。而编码过程比较复杂，
以开源的BC7e编解码器为例，编码过程具有分支、循环、位运算、量化舍入等不可微过程。

(2)编码配置选择问题：标准纹理块压缩工具在编码时通常会尝试使用多种编码配置进行
编解码，并选择使得编码误差最小的编码配置。
由于可微编解码器通常会与其他方法结合进行端到端优化，
优化过程中每次迭代都会进行一次可微编解码，因此在迭代中尝试大量编码配置的过程会带来显著的计算开销。

针对挑战(1)，本文分析了DXT格式的主要特点以及编码过程的本质问题，
并给出了解决本质问题的连续数学表达，使得DXT格式的编解码过程可以使用支持自动微分的张量计算工具Pytorch实现。
由于编码的量化过程使用的舍入函数梯度几乎处处为0，本文所提出的模型使用神经网络量化领域常用的直通估计器\cite{bengio2013estimating}(Straight-Through Estimator, STE)
将舍入函数的梯度近似为1，使得梯度的反向传播过程得以进行。

针对挑战(2)，本文提出了一种基于混合专家模型的分区配置选择器。该方
法将分区配置根据亲和度通过 TopK 排序，分为始终激活的稳定分区配置与通过随
机采样激活的随机分区配置。只需使用数量较少的稳定分区配置与随机分区配置，就能获得接近枚
举所有分区配置产生的编码质量，显著地减少了计算开销。

\section{研究现状}

\subsection{纹理块压缩技术}
目前国内外对于纹理块压缩技术已有充分的探索，在成果上产生了DXT、ETC、PVRTC和ASTC等高质量的纹理块压缩格式。
块截断编码(block truncation coding, BTC)\cite{delp1979image}
是第一种针对灰度图像的块压缩方法。对于每4\times4的像素块，
这种方法存储两个8位的灰度值端点，并使用每像素1位索引值选择两个灰度端点之一。
Campbell等\cite{campbell1986two}
通过引入256个值的调色板而不是灰度值，扩展了BTC以包含RGB颜色，
但需要额外的内存查找，使其不如硬件支持的通过单次纹理访问解码像素的格式。 
Knittel等\cite{knittel1996hardware}
通过添加硬件支持和纹理系统提出了对该方法的改进。
Iourcha等\cite{iourcha1999system}基于BTC的思想提出了PC平台上广泛使用的S3TC/DXT1格式。
在 S3TC 中，4\times4 RGB 块使用两个 RGB565 端点和每个纹素的两位索引进行编码。
根据其索引，每个纹素通过映射到由端点定义的 RGB 颜色空间中沿线段的四个点之一来重建。
微软在DirectX 6.0 中将S3TC命名为DXT1。之后的DXT2-5支持了带有 alpha 通道的纹理。
从 DirectX 10 开始，这些格式被称为 BC1-BC3。BC1格式将纹理分为4\times4大小的块，
每个块存储两个颜色端点与16个2位索引，每个纹素根据索引对颜色端点进行线性插值。
之后出现了用于法线贴图压缩的BC4 和 BC5。随着 DirectX 11 的发布，又推出了针对高动态范围 (HDR) 纹理的BC6H，
为高质量压缩而设计的BC7。BC7在BC1基础上支持了分区、旋转等更复杂的多模式压缩设置。
爱立信纹理压缩(ETC)格式被设计用于移动设备。该压缩方案的第一个版本 PACKMAN\cite{strom2004packman} 于 2004 年推出。
此格式中，2\times4 纹素块通过存储单个色度值进行编码，然后索引到亮度偏移表中以产生最终颜色。
2005年，PACKMAN的增强版本iPACKMAN\cite{strom2005packman}发布，通常称其为ETC1。
ETC1引入了垂直或水平分区，每4\times4纹素块存储两个PACKMAN块。
2007年，ETC2\cite{strom2007etc}通过为变化较大的块引入新的色度选项，进一步扩展了这种格式。
专为iOS设备设计的PowerVR 纹理压缩(PVRTC)方法于2003年由 Fenney\cite{fenney2003texture}提出。
这种格式使用两个或多个低分辨率图像，
通过一个全分辨率的高频调制信号线性插值低分辨率图像中双线性上采样的纹素从而生成解压缩的纹素。
自适应可扩展纹理压缩(ASTC)\cite{nystad2012adaptive}是目前最灵活的纹理压缩方案，
它由 ARM 和 AMD 联合开发，于 2012 年推出。
ASTC与BC7类似，将每个纹理块编码为颜色端点对与插值权重，并支持预定义分区。
独特的有界整数编码(BISE)、支持双线性上采样的权重网格等特性使得ASTC几乎成为目前最先进的纹理压缩格式。
ASTC由于没有受到PC端主流的图形接口DirectX支持，因此尚未被广泛用于PC平台，目前主要在移动设备上使用\cite{vaidyanathan2023random}。


\subsection{神经压缩}

目前已有许多与神经压缩相关的研究，这类研究通常采用多分辨率特征网格作为纹理的压缩表示，并通过神经解码器将特征解码为纹素。
Instant NGP\cite{muller2022instant}使用神经网络与特征网格表示纹理等图形基元，通过可训练特征向量的多分辨率哈希编码来增强小型神经网络的能力。
Compact NGP\cite{takikawa2023compact}在Instant NGP基础上引入了索引函数，改善了性能。
NTBC\cite{fujieda2024neural}使用多分辨率的特征网格表示一种材质中的所有纹理，并采用多层感知机(MLP)将特征网格中的特征向量解码为标准DXT格式纹理，
其中解码的网络推理过程可以在渲染前进行，因此没有额外的GPU开销。
NTBC旨在减少纹理在磁盘占用的空间，即在磁盘上对传统纹理块压缩格式通过神经网络进一步压缩，但没有改善显存与带宽占用。
NTC\cite{vaidyanathan2023random}使用多分辨率的特征网格压缩表示纹理集，允许进行随机访问并按需实时解压缩，与传统纹理块压缩技术相比在相同显存占用下
获得了更好的纹理压缩质量，但需要在渲染过程中进行网络推理，这产生了额外的GPU开销。
BCf\cite{weinreich2024real}在此基础上对特征网格使用BC6格式压缩，并在训练期间模拟 BC6 解压缩，从而进一步减少了显存占用。

BCf\cite{weinreich2024real}与本文的研究密切相关，不同之处在于本文研究DXT格式中BC1至BC7这7种格式编解码器的可微近似，
而BCf\cite{weinreich2024real}仅研究BC6格式的可微解码器。

\section{研究内容}

目前的块压缩方法已经可以以较高质量压缩艺术家通过建模软件导出的纹理。
但对于神经纹理（例如神经压缩模型中可学习的张量形式的神经特征），直接使用块压缩方法压缩会造成模型整体误差
显著增加。由于现有纹理块压缩工具不支持自动微分，为了在神经纹理的优化过程中加入块压缩的编解码过程，
从而降低神经纹理经过块压缩后导致神经压缩模型整体增加的误差，本文提出了一种DXT格式的可微块压缩模型，
通过Pytorch的C++版本实现了DXT格式的可微编解码器，可以整合到优化训练中进行基于梯度的端到端优化。
优化完成后可使用现有的DXT格式纹理块压缩工具对训练后的神经纹理进行高质量压缩，运行时通过GPU硬件解码神经纹理，
不会带来额外的计算开销。
本文提出的方法也适用于基于移动基分解的光照数据压缩技术\cite{silvennoinen2021moving}和
HDR纹理的RGBM编码技术。

具体来讲，本文进行了以下两个工作：

其一，本文提出了一种DXT格式的可微块压缩模型，支持BC1至BC7，包含可微编解码器，
可以作为DXT格式的可微近似整合到基于梯度的优化过程中并通过自动微分实现端到端优化，
从而减少神经纹理经过块压缩导致模型增加的整体误差。
本文提出的方法相较于BCf\cite{weinreich2024real}的BC6仅解码器模型，
通过加入可微编码器支持了优化过程中编码配置的动态选择，
更充分地利用了纹理块压缩格式的编码能力，同时对BC1至BC7这7种格式的支持使得本文的方法具有更好的通用性。

其二，针对分区配置选择的计算效率问题，本文提出了一种基于混合专家模型（Mixture of Experts）的分区配置选择器。
相较于枚举所有分区配置，在编码质量几乎不变的情况下，显著减少了计算开销。

最后在神经压缩\cite{weinreich2024real}、基于移动基分解的光照数据压缩\cite{silvennoinen2021moving}、HDR纹理的RGBM编码，三个应用场景中进行实验，以证明本文所提出方法的有效性。
本文提出的方法一定程度上解决了纹理块压缩技术的可微性问题，使得神经纹理可以更好地通过块压缩方法压缩，从而扩展了纹理块压缩技术的应用场景，
使其不仅局限于压缩传统材质纹理。

\section{论文的组织结构}

本文由五个章节组成，其组织结构和主要内容如下：

第一章：绪论。本章首先介绍了本文的研究背景、问题与挑战，然后分别阐述纹理
块压缩技术和神经压缩技术的研究现状，最后总结了本文的主要工作。

第二章：相关工作。本章主要介绍本研究相关的背景知识和相关工作。
首先介绍了DXT纹理格式、神经网络量化与混合专家模型。
然后对实验部分使用的神经压缩技术、基于移动基分解的光照数据压缩技术、HDR纹理的RGBM编码技术三个应用场景进行概述。

第三章：可微块压缩模型。本章主要介绍本文所提出的可微块压缩模型。
首先分析了DXT格式的主要特点与编码过程的本质问题，然后给出了解决编码过程本质问题的
连续数学表达，之后描述了模拟量化的过程并设计了配置选择器，为了使
浮点形式的神经纹理可以以BC7格式压缩存储，还设计了范围约束损失。
最后在神经压缩模型中对所提出的可微块压缩模型进行实验，验证了所提出方法的有效性。

第四章：基于混合专家模型的分区配置选择器。本章首先分析了
第三章中可微块压缩模型存在的问题，即穷举大量分区配置造成的较大计算开销。
然后基于混合专家模型，提出了一种通过随机采样与TopK排序实现的分区配置选择器
，可以在几乎不损失编码质量的前提下，显著减少需要计算的分区配置数。
最后在三个应用场景中对使用了分区配置选择器的可微块压缩模型进行了实验，
验证了所提出方法的有效性。

第五章：总结与展望。本章节对本文的研究内容进行了总结，并针对不足之处
提出未来可能的改进。

